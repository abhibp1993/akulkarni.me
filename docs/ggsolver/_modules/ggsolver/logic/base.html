


<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ggsolver.logic.base &#8212; ggsolver 0.1.6 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/cloud.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom.css" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noticia+Text:400,i,b,bi|Open+Sans:400,i,b,bi|Roboto+Mono:400,i,b,bi&amp;display=swap" type="text/css" />
    
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>

    
    
     
        <script src="../../../_static/jquery.cookie.js"></script>
    

    
     
        <script src="../../../_static/cloud.base.js"></script>
    

    
     
        <script src="../../../_static/cloud.js"></script>
    

    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
        <meta name="viewport" content="width=device-width, initial-scale=1">
  </head><body>
    <div class="relbar-top">
        
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
    <li><a href="../../../index.html">ggsolver 0.1.6 documentation</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">ggsolver.logic.base</a></li> 
      </ul>
    </div>
    </div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for ggsolver.logic.base</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">spot</span>
<span class="kn">from</span> <span class="nn">dd.autoref</span> <span class="kn">import</span> <span class="n">BDD</span>
<span class="kn">from</span> <span class="nn">ggsolver.logic.formula</span> <span class="kn">import</span> <span class="n">BaseFormula</span><span class="p">,</span> <span class="n">ParsingError</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>

<span class="kn">import</span> <span class="nn">ggsolver.util</span> <span class="k">as</span> <span class="nn">util</span>
<span class="kn">import</span> <span class="nn">ggsolver.models</span> <span class="k">as</span> <span class="nn">models</span>


<div class="viewcode-block" id="PL"><a class="viewcode-back" href="../../../modules/logic.html#ggsolver.logic.PL">[docs]</a><span class="k">class</span> <span class="nc">PL</span><span class="p">(</span><span class="n">BaseFormula</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    PL formula is internally represented as spot.formula instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f_str</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PL</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">f_str</span><span class="p">,</span> <span class="n">atoms</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_repr</span> <span class="o">=</span> <span class="n">spot</span><span class="o">.</span><span class="n">formula</span><span class="p">(</span><span class="n">f_str</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repr</span><span class="o">.</span><span class="n">is_boolean</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">ParsingError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Given formula:</span><span class="si">{</span><span class="n">f_str</span><span class="si">}</span><span class="s2"> is not a PL formula.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_collect_atoms</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f_str</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">BaseFormula</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">spot</span><span class="o">.</span><span class="n">are_equivalent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f_str</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">f_str</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_collect_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">traversal</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">spot</span><span class="o">.</span><span class="n">formula</span><span class="p">,</span> <span class="n">atoms_</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_literal</span><span class="p">():</span>
                <span class="k">if</span> <span class="s2">&quot;!&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">to_str</span><span class="p">():</span>
                    <span class="n">atoms_</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">to_str</span><span class="p">())</span>
                    <span class="k">return</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_repr</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">traversal</span><span class="p">,</span> <span class="n">atoms</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span> <span class="o">|</span> <span class="n">atoms</span>

    <span class="c1"># ==================================================================</span>
    <span class="c1"># IMPLEMENTATION OF ABSTRACT METHODS</span>
    <span class="c1"># ==================================================================</span>
<div class="viewcode-block" id="PL.translate"><a class="viewcode-back" href="../../../modules/logic.html#ggsolver.logic.PL.translate">[docs]</a>    <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Translate a propositional logic formula to an automaton.</span>
<span class="sd">        :return: (:class:`SpotAutomaton`) SpotAutomaton representing the automaton for PL formula.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SpotAutomaton</span><span class="p">(</span><span class="n">formula</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">f_str</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">())</span></div>

    <span class="k">def</span> <span class="nf">substitute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subs_map</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;To be implemented in future.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="PL.evaluate"><a class="viewcode-back" href="../../../modules/logic.html#ggsolver.logic.PL.evaluate">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">true_atoms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluates a propositional logic formula given the set of true atoms.</span>

<span class="sd">        :param true_atoms: (Iterable[str]) A propositional logic formula.</span>
<span class="sd">        :return: (bool) True if formula is true, otherwise False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Define a transform to apply to AST of spot.formula.</span>
        <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">spot</span><span class="o">.</span><span class="n">formula</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_literal</span><span class="p">():</span>
                <span class="k">if</span> <span class="s2">&quot;!&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">to_str</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">to_str</span><span class="p">()</span> <span class="ow">in</span> <span class="n">true_atoms</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">spot</span><span class="o">.</span><span class="n">formula</span><span class="o">.</span><span class="n">tt</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">spot</span><span class="o">.</span><span class="n">formula</span><span class="o">.</span><span class="n">ff</span><span class="p">()</span>

            <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">transform</span><span class="p">)</span>

        <span class="c1"># Apply the transform and return the result.</span>
        <span class="c1"># Since every literal is replaced by true or false,</span>
        <span class="c1">#   the transformed formula is guaranteed to be either true or false.</span>
        <span class="k">return</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_repr</span><span class="p">)</span><span class="o">.</span><span class="n">is_tt</span><span class="p">()</span> <span class="k">else</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="PL.atoms"><a class="viewcode-back" href="../../../modules/logic.html#ggsolver.logic.PL.atoms">[docs]</a>    <span class="k">def</span> <span class="nf">atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the list of atoms associated with PL formula.</span>

<span class="sd">        The list may contain atoms that do not appear in the formula, if the user has provided it.</span>
<span class="sd">        :return: (List[str]) List of atoms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span></div>

    <span class="c1"># ==================================================================</span>
    <span class="c1"># SPECIAL METHODS OF PL CLASS</span>
    <span class="c1"># ==================================================================</span>
<div class="viewcode-block" id="PL.simplify"><a class="viewcode-back" href="../../../modules/logic.html#ggsolver.logic.PL.simplify">[docs]</a>    <span class="k">def</span> <span class="nf">simplify</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simplifies a propositional logic formula.</span>

<span class="sd">        We use the `boolean_to_isop=True` option for `spot.simplify`.</span>
<span class="sd">        See https://spot.lrde.epita.fr/doxygen/classspot_1_1tl__simplifier__options.html</span>

<span class="sd">        :return: (str) String representing simplified formula.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">spot</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_repr</span><span class="p">,</span> <span class="n">boolean_to_isop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">to_str</span><span class="p">()</span></div>

<div class="viewcode-block" id="PL.allsat"><a class="viewcode-back" href="../../../modules/logic.html#ggsolver.logic.PL.allsat">[docs]</a>    <span class="k">def</span> <span class="nf">allsat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates the set of all satisfying assignments to atoms of the given propositional logic formula.</span>

<span class="sd">        .. note:: Complexity: Exponential in the number of atoms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Apply limitation on atoms we allow in ggsolver. Raises ValueError if |atoms| exceeds limit.</span>
        <span class="n">util</span><span class="o">.</span><span class="n">apply_atoms_limit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">())</span>

        <span class="c1"># For each assignment, check whether the formula evaluates to True.</span>
        <span class="c1"># If yes, include it in set of all satisfying assignments.</span>
        <span class="n">sat_assignments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">assignment</span> <span class="ow">in</span> <span class="n">util</span><span class="o">.</span><span class="n">powerset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">()):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">assignment</span><span class="p">):</span>
                <span class="n">sat_assignments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">assignment</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sat_assignments</span></div></div>


<div class="viewcode-block" id="Automaton"><a class="viewcode-back" href="../../../modules/models.html#ggsolver.logic.Automaton">[docs]</a><span class="k">class</span> <span class="nc">Automaton</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">GraphicalModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents an Automaton.</span>

<span class="sd">    .. math::</span>
<span class="sd">        \\mathcal{A} = (Q, \\Sigma := 2^{AP}, \\delta, q_0, F)</span>

<span class="sd">    In the `Automaton` class, each component is represented as a function.</span>

<span class="sd">    - The set of states :math:`Q` is represented by `Automaton.states` function,</span>
<span class="sd">    - The set of atomic propositions :math:`AP` is represented by `Automaton.atoms` function,</span>
<span class="sd">    - The set of symbols :math:`\\Sigma` is represented by `Automaton.sigma` function,</span>
<span class="sd">    - The transition function :math:`\\delta` is represented by `Automaton.delta` function,</span>
<span class="sd">    - The initial state :math:`q_0` is represented by `Automaton.init_state` function.</span>

<span class="sd">    An automaton may have one of the following acceptance conditions:</span>

<span class="sd">    - (:class:`Automaton.ACC_REACH`, 0)</span>
<span class="sd">    - (:class:`Automaton.ACC_SAFETY`, 0)</span>
<span class="sd">    - (:class:`Automaton.ACC_BUCHI`, 0)</span>
<span class="sd">    - (:class:`Automaton.ACC_COBUCHI`, 0)</span>
<span class="sd">    - (:class:`Automaton.ACC_PARITY`, 0)</span>
<span class="sd">    - (:class:`Automaton.ACC_PREF_LAST`, None)</span>
<span class="sd">    - (:class:`Automaton.ACC_ACC_PREF_MP`, None)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">NODE_PROPERTY</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">GraphicalModel</span><span class="o">.</span><span class="n">NODE_PROPERTY</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">EDGE_PROPERTY</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">GraphicalModel</span><span class="o">.</span><span class="n">EDGE_PROPERTY</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">GRAPH_PROPERTY</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">GraphicalModel</span><span class="o">.</span><span class="n">GRAPH_PROPERTY</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">ACC_REACH</span> <span class="o">=</span> <span class="s2">&quot;Reach&quot;</span>                                 <span class="c1">#:</span>
    <span class="n">ACC_SAFETY</span> <span class="o">=</span> <span class="s2">&quot;Safety&quot;</span>                               <span class="c1">#:</span>
    <span class="n">ACC_BUCHI</span> <span class="o">=</span> <span class="s2">&quot;Buchi&quot;</span>                                 <span class="c1">#:</span>
    <span class="n">ACC_COBUCHI</span> <span class="o">=</span> <span class="s2">&quot;co-Buchi&quot;</span>                            <span class="c1">#:</span>
    <span class="n">ACC_PARITY</span> <span class="o">=</span> <span class="s2">&quot;Parity Min Even&quot;</span>                      <span class="c1">#:</span>
    <span class="n">ACC_PREF_LAST</span> <span class="o">=</span> <span class="s2">&quot;Preference Last&quot;</span>                   <span class="c1">#:</span>
    <span class="n">ACC_PREF_MP</span> <span class="o">=</span> <span class="s2">&quot;Preference MostPreferred&quot;</span>            <span class="c1">#:</span>
    <span class="n">ACC_UNDEFINED</span> <span class="o">=</span> <span class="s2">&quot;undefined&quot;</span>
    <span class="n">ACC_TYPES</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">ACC_UNDEFINED</span><span class="p">,</span>
        <span class="n">ACC_REACH</span><span class="p">,</span>
        <span class="n">ACC_SAFETY</span><span class="p">,</span>
        <span class="n">ACC_BUCHI</span><span class="p">,</span>
        <span class="n">ACC_COBUCHI</span><span class="p">,</span>
        <span class="n">ACC_PARITY</span><span class="p">,</span>
        <span class="n">ACC_PREF_LAST</span><span class="p">,</span>
        <span class="n">ACC_PREF_MP</span>
    <span class="p">]</span>                                   <span class="c1">#: Acceptance conditions supported by Automaton.</span>

<div class="viewcode-block" id="Automaton.__init__"><a class="viewcode-back" href="../../../modules/models.html#ggsolver.logic.Automaton.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Supported keyword arguments:</span>

<span class="sd">        :param states: (Iterable) An iterable over states in the automaton.</span>
<span class="sd">        :param atoms: (Iterable[str]) An iterable over atomic propositions in the automaton.</span>
<span class="sd">        :param trans_dict: (dict) A dictionary defining the (deterministic) transition function of automaton.</span>
<span class="sd">                      Format of dictionary: {state: {logic.PLFormula: state}}</span>
<span class="sd">        :param init_state: (object) The initial state, a member of states iterable.</span>
<span class="sd">        :param final: (Iterable[states]) The set of final states, a subset of states iterable.</span>
<span class="sd">        :param acc_cond: (tuple) A tuple of automaton acceptance type and an acceptance set.</span>
<span class="sd">            For example, DFA has an acceptance condition of `(Automaton.ACC_REACH, 0)`.</span>
<span class="sd">        :param is_deterministic: (bool) Whether the Automaton is deterministic.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;input_domain&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;atoms&quot;</span> <span class="k">if</span> <span class="s2">&quot;input_domain&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;input_domain&quot;</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Automaton</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Process keyword arguments</span>
        <span class="k">if</span> <span class="s2">&quot;states&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">states_</span><span class="p">():</span>
                <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;states&quot;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="n">states_</span>

        <span class="k">if</span> <span class="s2">&quot;atoms&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">atoms_</span><span class="p">():</span>
                <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;atoms&quot;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span> <span class="o">=</span> <span class="n">atoms_</span>

        <span class="k">if</span> <span class="s2">&quot;trans_dict&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">delta_</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">inp</span><span class="p">):</span>
                <span class="n">next_states</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">formula</span><span class="p">,</span> <span class="n">n_state</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;trans_dict&quot;</span><span class="p">][</span><span class="n">state</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">PL</span><span class="p">(</span><span class="n">f_str</span><span class="o">=</span><span class="n">formula</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">())</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">inp</span><span class="p">):</span>
                        <span class="n">next_states</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">n_state</span><span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_deterministic</span><span class="p">():</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">next_states</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Non-determinism detected in a deterministic automaton. &quot;</span> <span class="o">+</span>
                                         <span class="sa">f</span><span class="s2">&quot;delta(</span><span class="si">{</span><span class="n">state</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">inp</span><span class="si">}</span><span class="s2">) -&gt; </span><span class="si">{</span><span class="n">next_states</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
                    <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">next_states</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">next_states</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="kc">None</span>

                <span class="k">return</span> <span class="n">next_states</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="o">=</span> <span class="n">delta_</span>

        <span class="k">if</span> <span class="s2">&quot;init_state&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;init_state&quot;</span><span class="p">])</span>

        <span class="k">if</span> <span class="s2">&quot;final&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">final_</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;final&quot;</span><span class="p">]</span> <span class="k">else</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">final</span> <span class="o">=</span> <span class="n">final_</span>

        <span class="k">if</span> <span class="s2">&quot;acc_cond&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">acc_cond_</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;acc_cond&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">acc_cond</span> <span class="o">=</span> <span class="n">acc_cond_</span>

        <span class="k">if</span> <span class="s2">&quot;is_deterministic&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">is_deterministic_</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;is_deterministic&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">is_deterministic</span> <span class="o">=</span> <span class="n">is_deterministic_</span></div>

    <span class="c1"># ==========================================================================</span>
    <span class="c1"># PRIVATE FUNCTIONS</span>
    <span class="c1"># ==========================================================================</span>
    <span class="k">def</span> <span class="nf">_gen_underlying_graph_unpointed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Programmer&#39;s notes:</span>
<span class="sd">        1. Caches states (returned by `self.states()`) in self.__states variable.</span>
<span class="sd">        2. Assumes all states to be hashable.</span>
<span class="sd">        3. Parallel edges are merged using ORing of PL Formulas.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get states</span>
        <span class="n">states</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;states&quot;</span><span class="p">)</span>
        <span class="n">states</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">states</span><span class="p">())</span>

        <span class="c1"># Add states to graph</span>
        <span class="n">node_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">add_nodes</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">states</span><span class="p">)))</span>

        <span class="c1"># Cache states as a dictionary {state: uid}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__states</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">states</span><span class="p">,</span> <span class="n">node_ids</span><span class="p">))</span>

        <span class="c1"># Node property: state</span>
        <span class="n">np_state</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">NodePropertyMap</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">)</span>
        <span class="n">np_state</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">node_ids</span><span class="p">,</span> <span class="n">states</span><span class="p">)))</span>
        <span class="n">graph</span><span class="p">[</span><span class="s2">&quot;state&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np_state</span>

        <span class="c1"># Logging and printing</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">ColoredMsg</span><span class="o">.</span><span class="n">ok</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[INFO] Processed node property: states. Added </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">node_ids</span><span class="p">)</span><span class="si">}</span><span class="s2"> states. [OK]&quot;</span><span class="p">))</span>

        <span class="c1"># Get input function</span>
        <span class="c1">#   Specialized for automaton class: we expect input function to be atoms.</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_domain</span> <span class="o">==</span> <span class="s2">&quot;atoms&quot;</span><span class="p">,</span> <span class="s2">&quot;For automaton class, we expect input domain to be `atoms`. &quot;</span> \
                                              <span class="sa">f</span><span class="s2">&quot;Currently it is set to &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_input_domain</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
        <span class="n">input_func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_domain</span><span class="p">)</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">input_func</span><span class="p">()</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">powerset</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">ColoredMsg</span><span class="o">.</span><span class="n">ok</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[INFO] Input domain function detected as &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_input_domain</span><span class="si">}</span><span class="s2">&#39;. [OK]&quot;</span><span class="p">))</span>

        <span class="c1"># Graph property: input domain (stores the name of edge property that represents inputs)</span>
        <span class="n">graph</span><span class="p">[</span><span class="s2">&quot;input_domain&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_domain</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">ColoredMsg</span><span class="o">.</span><span class="n">ok</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[INFO] Processed graph property: input_domain. [OK]&quot;</span><span class="p">))</span>

        <span class="c1"># # Get input domain</span>
        <span class="c1"># inputs = input_func()</span>

        <span class="c1"># Edge properties: input, prob,</span>
        <span class="n">ep_input</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">EdgePropertyMap</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">)</span>
        <span class="n">ep_prob</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">EdgePropertyMap</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Generate edges</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;delta&quot;</span><span class="p">)</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">{</span><span class="n">uid</span><span class="p">:</span> <span class="nb">dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">uid</span> <span class="ow">in</span> <span class="n">node_ids</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">state</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__states</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">inputs</span><span class="p">),</span>
                               <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__states</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">**</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">),</span>
                               <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Specialized unpointed graphify adding edges for automaton &quot;</span><span class="p">):</span>

            <span class="n">new_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_edges</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">inp</span><span class="p">)</span>

            <span class="c1"># Update graph edges</span>
            <span class="n">uid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__states</span><span class="p">[</span><span class="n">state</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">new_edges</span><span class="p">:</span>
                <span class="n">vid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__states</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">vid</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">[</span><span class="n">uid</span><span class="p">]:</span>
                    <span class="n">edges</span><span class="p">[</span><span class="n">uid</span><span class="p">][</span><span class="n">vid</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
                <span class="n">edges</span><span class="p">[</span><span class="n">uid</span><span class="p">][</span><span class="n">vid</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">uid</span> <span class="ow">in</span> <span class="n">edges</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">vid</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">[</span><span class="n">uid</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">uid</span><span class="p">,</span> <span class="n">vid</span><span class="p">)</span>
                <span class="n">ep_input</span><span class="p">[</span><span class="n">uid</span><span class="p">,</span> <span class="n">vid</span><span class="p">,</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">sat2formula</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">edges</span><span class="p">[</span><span class="n">uid</span><span class="p">][</span><span class="n">vid</span><span class="p">])</span>
                <span class="n">ep_prob</span><span class="p">[</span><span class="n">uid</span><span class="p">,</span> <span class="n">vid</span><span class="p">,</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Add edge properties to graph</span>
        <span class="n">graph</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ep_input</span>
        <span class="n">graph</span><span class="p">[</span><span class="s2">&quot;prob&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ep_prob</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">ColoredMsg</span><span class="o">.</span><span class="n">ok</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[INFO] Processed edge property: input. [OK]&quot;</span><span class="p">))</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">ColoredMsg</span><span class="o">.</span><span class="n">ok</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[INFO] Processed graph property: prob. [OK]&quot;</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_gen_underlying_graph_pointed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Pointed graphify is not defined for automaton.&quot;</span><span class="p">)</span>

    <span class="c1"># ==========================================================================</span>
    <span class="c1"># FUNCTIONS TO BE IMPLEMENTED BY USER.</span>
    <span class="c1"># ==========================================================================</span>
<div class="viewcode-block" id="Automaton.atoms"><a class="viewcode-back" href="../../../modules/models.html#ggsolver.logic.Automaton.atoms">[docs]</a>    <span class="nd">@models</span><span class="o">.</span><span class="n">register_property</span><span class="p">(</span><span class="n">GRAPH_PROPERTY</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list/tuple of atomic propositions.</span>

<span class="sd">        :return: (list of str) A list of atomic proposition.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.atoms() is not implemented.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Automaton.final"><a class="viewcode-back" href="../../../modules/models.html#ggsolver.logic.Automaton.final">[docs]</a>    <span class="nd">@models</span><span class="o">.</span><span class="n">register_property</span><span class="p">(</span><span class="n">NODE_PROPERTY</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">final</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the acceptance set associated with the given state.</span>

<span class="sd">        :param state: (an element of `self.states()`) A valid state.</span>
<span class="sd">        :return: (int) Acceptance set associated with the given state.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.final() is not implemented.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Automaton.acc_type"><a class="viewcode-back" href="../../../modules/models.html#ggsolver.logic.Automaton.acc_type">[docs]</a>    <span class="nd">@models</span><span class="o">.</span><span class="n">register_property</span><span class="p">(</span><span class="n">GRAPH_PROPERTY</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">acc_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Acceptance type of the automaton.</span>

<span class="sd">        :return: A value from :class:`Automaton.ACC_TYPES`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">acc_cond</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Automaton.acc_cond"><a class="viewcode-back" href="../../../modules/models.html#ggsolver.logic.Automaton.acc_cond">[docs]</a>    <span class="nd">@models</span><span class="o">.</span><span class="n">register_property</span><span class="p">(</span><span class="n">GRAPH_PROPERTY</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">acc_cond</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Acceptance condition of the automaton.</span>

<span class="sd">        :return: (2-tuple) A value of type (acc_type, acc_set) where acc_type is from :class:`Automaton.ACC_TYPES`</span>
<span class="sd">                 and acc_set is either an integer or a list of integer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ACC_UNDEFINED</span><span class="p">,</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Automaton.num_acc_sets"><a class="viewcode-back" href="../../../modules/models.html#ggsolver.logic.Automaton.num_acc_sets">[docs]</a>    <span class="nd">@models</span><span class="o">.</span><span class="n">register_property</span><span class="p">(</span><span class="n">GRAPH_PROPERTY</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">num_acc_sets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of acceptance sets.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.num_acc_sets() is not implemented.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Automaton.is_complete"><a class="viewcode-back" href="../../../modules/models.html#ggsolver.logic.Automaton.is_complete">[docs]</a>    <span class="nd">@models</span><span class="o">.</span><span class="n">register_property</span><span class="p">(</span><span class="n">GRAPH_PROPERTY</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">is_complete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Is the automaton complete? That is, is transition function well-defined at every state for any</span>
<span class="sd">        input symbol?</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

    <span class="c1"># ==========================================================================</span>
    <span class="c1"># FUNCTIONS TO BE IMPLEMENTED BY USER.</span>
    <span class="c1"># ==========================================================================</span>
<div class="viewcode-block" id="Automaton.sigma"><a class="viewcode-back" href="../../../modules/models.html#ggsolver.logic.Automaton.sigma">[docs]</a>    <span class="k">def</span> <span class="nf">sigma</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the set of alphabet of automaton. It is the powerset of atoms().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">powerset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">()))</span></div>

<div class="viewcode-block" id="Automaton.from_automaton"><a class="viewcode-back" href="../../../modules/models.html#ggsolver.logic.Automaton.from_automaton">[docs]</a>    <span class="k">def</span> <span class="nf">from_automaton</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aut</span><span class="p">:</span> <span class="s1">&#39;Automaton&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs an Automaton from another Automaton instance.</span>
<span class="sd">        The input automaton&#39;s acceptance condition must match that of a current Automaton.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">aut</span><span class="o">.</span><span class="n">acc_cond</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">acc_cond</span><span class="p">(),</span> <span class="sa">f</span><span class="s2">&quot;aut.acc_cond(): </span><span class="si">{</span><span class="n">aut</span><span class="o">.</span><span class="n">acc_cond</span><span class="p">()</span><span class="si">}</span><span class="s2">, self.acc_cond(): </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">acc_cond</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="c1"># Copy all functions from automaton.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="n">aut</span><span class="o">.</span><span class="n">states</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="o">=</span> <span class="n">aut</span><span class="o">.</span><span class="n">delta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_input_domain</span> <span class="o">=</span> <span class="s2">&quot;atoms&quot;</span>

        <span class="k">for</span> <span class="n">gp</span> <span class="ow">in</span> <span class="n">aut</span><span class="o">.</span><span class="n">GRAPH_PROPERTY</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gp</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">aut</span><span class="p">,</span> <span class="n">gp</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">np</span> <span class="ow">in</span> <span class="n">aut</span><span class="o">.</span><span class="n">NODE_PROPERTY</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">np</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">aut</span><span class="p">,</span> <span class="n">np</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">ep</span> <span class="ow">in</span> <span class="n">aut</span><span class="o">.</span><span class="n">EDGE_PROPERTY</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">aut</span><span class="p">,</span> <span class="n">ep</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="SpotAutomaton"><a class="viewcode-back" href="../../../modules/logic.html#ggsolver.logic.SpotAutomaton">[docs]</a><span class="k">class</span> <span class="nc">SpotAutomaton</span><span class="p">(</span><span class="n">Automaton</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `SpotAutomaton` constructs an :class:`Automaton` from an LTL specification string using</span>
<span class="sd">    `spot` (https://spot.lrde.epita.fr/) with customizations for `ggsolver`.</span>

<span class="sd">    **Customizations:** Since `ggsolver` contains several algorithms for reactive/controller synthesis,</span>
<span class="sd">    we prefer to construct deterministic automata. Given an LTL formula, `SpotAutomaton` automatically</span>
<span class="sd">    determines the best acceptance condition that would result in a deterministic automaton..</span>

<span class="sd">    Programmer&#39;s note: The graphified version of automaton does not use PL formulas as edge labels.</span>
<span class="sd">    This is intentionally done to be able to run our codes on robots that may not have logic libraries installed.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">formula</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given an LTL formula, SpotAutomaton determines the best options for spot.translate() function</span>
<span class="sd">        to generate a deterministic automaton in ggsolver.Automaton format.</span>

<span class="sd">        :param formula: (str) LTL formula.</span>
<span class="sd">        :param options: (List/Tuple of str) Valid options for spot.translate() function. By default, the</span>
<span class="sd">            value is `None`, in which case, the options are determined automatically. See description below.</span>

<span class="sd">        **Default translation options:** While constructing an automaton using `spot`, we use the following</span>
<span class="sd">        options: `deterministic, high, complete, unambiguous, SBAcc`. If selected acceptance condition</span>
<span class="sd">        is parity, then we use `colored` option as well.</span>

<span class="sd">        The default options can be overriden. For quick reference, the following description is copied from</span>
<span class="sd">        `spot` documentation (spot.lrde.epita.fr/doxygen).</span>

<span class="sd">        The optional arguments should be strings among the following:</span>
<span class="sd">        - at most one in &#39;GeneralizedBuchi&#39;, &#39;Buchi&#39;, or &#39;Monitor&#39;,</span>
<span class="sd">        &#39;generic&#39;, &#39;parity&#39;, &#39;parity min odd&#39;, &#39;parity min even&#39;,</span>
<span class="sd">        &#39;parity max odd&#39;, &#39;parity max even&#39;, &#39;coBuchi&#39;</span>
<span class="sd">        (type of acceptance condition to build)</span>

<span class="sd">        - at most one in &#39;Small&#39;, &#39;Deterministic&#39;, &#39;Any&#39;</span>
<span class="sd">          (preferred characteristics of the produced automaton)</span>
<span class="sd">        - at most one in &#39;Low&#39;, &#39;Medium&#39;, &#39;High&#39;</span>
<span class="sd">          (optimization level)</span>
<span class="sd">        - any combination of &#39;Complete&#39;, &#39;Unambiguous&#39;,</span>
<span class="sd">          &#39;StateBasedAcceptance&#39; (or &#39;SBAcc&#39; for short), and</span>
<span class="sd">          &#39;Colored&#39; (only for parity acceptance)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Construct the automaton</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SpotAutomaton</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">input_domain</span><span class="o">=</span><span class="s2">&quot;atoms&quot;</span><span class="p">)</span>

        <span class="c1"># Instance variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_formula</span> <span class="o">=</span> <span class="n">formula</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_user_atoms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># If options are not given, determine the set of options to generate deterministic automaton with</span>
        <span class="c1"># state-based acceptance condition.</span>
        <span class="k">if</span> <span class="n">options</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">options</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_determine_options</span><span class="p">()</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[INFO] Translating </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_formula</span><span class="si">}</span><span class="s2"> with options=</span><span class="si">{</span><span class="n">options</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spot_aut</span> <span class="o">=</span> <span class="n">spot</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">formula</span><span class="p">,</span> <span class="o">*</span><span class="n">options</span><span class="p">)</span>

        <span class="c1"># Set the acceptance condition (in ggsolver terms)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spot_aut</span><span class="o">.</span><span class="n">acc</span><span class="p">()</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Bchi&quot;</span> <span class="ow">and</span> <span class="n">spot</span><span class="o">.</span><span class="n">mp_class</span><span class="p">(</span><span class="n">formula</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="s2">&quot;S&quot;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_acc_cond</span> <span class="o">=</span> <span class="p">(</span><span class="n">Automaton</span><span class="o">.</span><span class="n">ACC_SAFETY</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Bchi&quot;</span> <span class="ow">and</span> <span class="n">spot</span><span class="o">.</span><span class="n">mp_class</span><span class="p">(</span><span class="n">formula</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;G&quot;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_acc_cond</span> <span class="o">=</span> <span class="p">(</span><span class="n">Automaton</span><span class="o">.</span><span class="n">ACC_REACH</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Bchi&quot;</span> <span class="ow">and</span> <span class="n">spot</span><span class="o">.</span><span class="n">mp_class</span><span class="p">(</span><span class="n">formula</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;O&quot;</span><span class="p">,</span> <span class="s2">&quot;R&quot;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_acc_cond</span> <span class="o">=</span> <span class="p">(</span><span class="n">Automaton</span><span class="o">.</span><span class="n">ACC_BUCHI</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;co-Bchi&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_acc_cond</span> <span class="o">=</span> <span class="p">(</span><span class="n">Automaton</span><span class="o">.</span><span class="n">ACC_COBUCHI</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_acc_cond</span> <span class="o">=</span> <span class="p">(</span><span class="n">Automaton</span><span class="o">.</span><span class="n">ACC_SAFETY</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># name contains &quot;parity&quot;:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_acc_cond</span> <span class="o">=</span> <span class="p">(</span><span class="n">Automaton</span><span class="o">.</span><span class="n">ACC_PARITY</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_determine_options</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the options based on where the given LTL formula lies in Manna-Pnueli hierarchy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mp_cls</span> <span class="o">=</span> <span class="n">spot</span><span class="o">.</span><span class="n">mp_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">formula</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">mp_cls</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;B&quot;</span> <span class="ow">or</span> <span class="n">mp_cls</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;S&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;Monitor&#39;</span><span class="p">,</span> <span class="s2">&quot;Deterministic&quot;</span><span class="p">,</span> <span class="s2">&quot;High&quot;</span><span class="p">,</span> <span class="s2">&quot;Complete&quot;</span><span class="p">,</span> <span class="s2">&quot;Unambiguous&quot;</span><span class="p">,</span> <span class="s2">&quot;SBAcc&quot;</span>
        <span class="k">elif</span> <span class="n">mp_cls</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;G&quot;</span> <span class="ow">or</span> <span class="n">mp_cls</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;O&quot;</span> <span class="ow">or</span> <span class="n">mp_cls</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;R&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;Buchi&#39;</span><span class="p">,</span> <span class="s2">&quot;Deterministic&quot;</span><span class="p">,</span> <span class="s2">&quot;High&quot;</span><span class="p">,</span> <span class="s2">&quot;Complete&quot;</span><span class="p">,</span> <span class="s2">&quot;Unambiguous&quot;</span><span class="p">,</span> <span class="s2">&quot;SBAcc&quot;</span>
        <span class="k">elif</span> <span class="n">mp_cls</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;P&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;coBuchi&#39;</span><span class="p">,</span> <span class="s2">&quot;Deterministic&quot;</span><span class="p">,</span> <span class="s2">&quot;High&quot;</span><span class="p">,</span> <span class="s2">&quot;Complete&quot;</span><span class="p">,</span> <span class="s2">&quot;Unambiguous&quot;</span><span class="p">,</span> <span class="s2">&quot;SBAcc&quot;</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># cls.upper() == &quot;T&quot;:</span>
            <span class="k">return</span> <span class="s1">&#39;parity min even&#39;</span><span class="p">,</span> <span class="s2">&quot;Deterministic&quot;</span><span class="p">,</span> <span class="s2">&quot;High&quot;</span><span class="p">,</span> <span class="s2">&quot;Complete&quot;</span><span class="p">,</span> <span class="s2">&quot;Unambiguous&quot;</span><span class="p">,</span> <span class="s2">&quot;SBAcc&quot;</span><span class="p">,</span> <span class="s2">&quot;colored&quot;</span>

<div class="viewcode-block" id="SpotAutomaton.states"><a class="viewcode-back" href="../../../modules/logic.html#ggsolver.logic.SpotAutomaton.states">[docs]</a>    <span class="k">def</span> <span class="nf">states</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; States of automaton. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spot_aut</span><span class="o">.</span><span class="n">num_states</span><span class="p">()))</span></div>

<div class="viewcode-block" id="SpotAutomaton.atoms"><a class="viewcode-back" href="../../../modules/logic.html#ggsolver.logic.SpotAutomaton.atoms">[docs]</a>    <span class="k">def</span> <span class="nf">atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Atomic propositions appearing in LTL formula. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">({</span><span class="nb">str</span><span class="p">(</span><span class="n">ap</span><span class="p">)</span> <span class="k">for</span> <span class="n">ap</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spot_aut</span><span class="o">.</span><span class="n">ap</span><span class="p">()}</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_atoms</span><span class="p">)</span></div>

<div class="viewcode-block" id="SpotAutomaton.delta"><a class="viewcode-back" href="../../../modules/logic.html#ggsolver.logic.SpotAutomaton.delta">[docs]</a>    <span class="k">def</span> <span class="nf">delta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">inp</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transition function of automaton. For a deterministic automaton, returns a single state. Otherwise,</span>
<span class="sd">        returns a list/tuple of states.</span>

<span class="sd">        :param state: (object) A valid state.</span>
<span class="sd">        :param inp: (list) List of atoms that are true (an element of sigma).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Preprocess inputs</span>
        <span class="n">inp_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">p</span><span class="p">:</span> <span class="kc">True</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">inp</span><span class="p">}</span> <span class="o">|</span> <span class="p">{</span><span class="n">p</span><span class="p">:</span> <span class="kc">False</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">()</span> <span class="k">if</span> <span class="n">p</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">inp</span><span class="p">}</span>

        <span class="c1"># Initialize a BDD over set of atoms.</span>
        <span class="n">bdd</span> <span class="o">=</span> <span class="n">BDD</span><span class="p">()</span>
        <span class="n">bdd</span><span class="o">.</span><span class="n">declare</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">())</span>

        <span class="c1"># Get spot BDD dict to extract formula</span>
        <span class="n">bdd_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spot_aut</span><span class="o">.</span><span class="n">get_dict</span><span class="p">()</span>

        <span class="c1"># Get next states</span>
        <span class="n">next_states</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spot_aut</span><span class="o">.</span><span class="n">out</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">spot</span><span class="o">.</span><span class="n">bdd_format_formula</span><span class="p">(</span><span class="n">bdd_dict</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">cond</span><span class="p">)</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">spot</span><span class="o">.</span><span class="n">formula</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">label</span><span class="o">.</span><span class="n">is_ff</span><span class="p">():</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">label</span><span class="o">.</span><span class="n">is_tt</span><span class="p">():</span>
                <span class="n">next_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">dst</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">label</span> <span class="o">=</span> <span class="n">spot</span><span class="o">.</span><span class="n">formula</span><span class="p">(</span><span class="n">label</span><span class="p">)</span><span class="o">.</span><span class="n">to_str</span><span class="p">(</span><span class="s1">&#39;spin&#39;</span><span class="p">)</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">bdd</span><span class="o">.</span><span class="n">add_expr</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">bdd</span><span class="o">.</span><span class="n">let</span><span class="p">(</span><span class="n">inp_dict</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="n">bdd</span><span class="o">.</span><span class="n">true</span><span class="p">:</span>
                    <span class="n">next_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">dst</span><span class="p">))</span>

        <span class="c1"># Return based on whether automaton is deterministic or non-deterministic.</span>
        <span class="c1">#   If automaton is deterministic but len(next_states) = 0, then automaton is incomplete, return None.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_deterministic</span><span class="p">()</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">next_states</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">next_states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_deterministic</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">next_states</span></div>

<div class="viewcode-block" id="SpotAutomaton.init_state"><a class="viewcode-back" href="../../../modules/logic.html#ggsolver.logic.SpotAutomaton.init_state">[docs]</a>    <span class="k">def</span> <span class="nf">init_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Initial state of automaton. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spot_aut</span><span class="o">.</span><span class="n">get_init_state_number</span><span class="p">())</span></div>

<div class="viewcode-block" id="SpotAutomaton.final"><a class="viewcode-back" href="../../../modules/logic.html#ggsolver.logic.SpotAutomaton.final">[docs]</a>    <span class="k">def</span> <span class="nf">final</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Maps every state to its acceptance set. &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_state_based_acc</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spot_aut</span><span class="o">.</span><span class="n">state_acc_sets</span><span class="p">(</span><span class="n">state</span><span class="p">)</span><span class="o">.</span><span class="n">sets</span><span class="p">())</span></div>

<div class="viewcode-block" id="SpotAutomaton.acc_cond"><a class="viewcode-back" href="../../../modules/logic.html#ggsolver.logic.SpotAutomaton.acc_cond">[docs]</a>    <span class="k">def</span> <span class="nf">acc_cond</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns acceptance condition according to ggsolver definitions:</span>
<span class="sd">        See `ACC_REACH, ...` variables in Automaton class.</span>
<span class="sd">        See :meth:`SpotAutomaton.spot_acc_cond` for acceptance condition in spot&#39;s nomenclature.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_acc_cond</span></div>

<div class="viewcode-block" id="SpotAutomaton.num_acc_sets"><a class="viewcode-back" href="../../../modules/logic.html#ggsolver.logic.SpotAutomaton.num_acc_sets">[docs]</a>    <span class="k">def</span> <span class="nf">num_acc_sets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Number of acceptance sets. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spot_aut</span><span class="o">.</span><span class="n">num_sets</span><span class="p">()</span></div>

<div class="viewcode-block" id="SpotAutomaton.is_deterministic"><a class="viewcode-back" href="../../../modules/logic.html#ggsolver.logic.SpotAutomaton.is_deterministic">[docs]</a>    <span class="k">def</span> <span class="nf">is_deterministic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Is the automaton deterministic? &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spot_aut</span><span class="o">.</span><span class="n">prop_universal</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">spot_aut</span><span class="o">.</span><span class="n">is_existential</span><span class="p">())</span></div>

<div class="viewcode-block" id="SpotAutomaton.is_unambiguous"><a class="viewcode-back" href="../../../modules/logic.html#ggsolver.logic.SpotAutomaton.is_unambiguous">[docs]</a>    <span class="k">def</span> <span class="nf">is_unambiguous</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        There is at most one run accepting a word (but it might be recognized several time).</span>
<span class="sd">        See https://spot.lrde.epita.fr/concepts.html.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spot_aut</span><span class="o">.</span><span class="n">prop_unambiguous</span><span class="p">())</span></div>

<div class="viewcode-block" id="SpotAutomaton.is_terminal"><a class="viewcode-back" href="../../../modules/logic.html#ggsolver.logic.SpotAutomaton.is_terminal">[docs]</a>    <span class="k">def</span> <span class="nf">is_terminal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Automaton is weak, accepting SCCs are complete, accepting edges may not go to rejecting SCCs.</span>
<span class="sd">        An automaton is weak if the transitions of an SCC all belong to the same acceptance sets.</span>

<span class="sd">        See https://spot.lrde.epita.fr/concepts.html</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spot_aut</span><span class="o">.</span><span class="n">prop_terminal</span><span class="p">())</span></div>

<div class="viewcode-block" id="SpotAutomaton.is_stutter_invariant"><a class="viewcode-back" href="../../../modules/logic.html#ggsolver.logic.SpotAutomaton.is_stutter_invariant">[docs]</a>    <span class="k">def</span> <span class="nf">is_stutter_invariant</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The property recognized by the automaton is stutter-invariant</span>
<span class="sd">        (see https://www.lrde.epita.fr/~adl/dl/adl/michaud.15.spin.pdf)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spot_aut</span><span class="o">.</span><span class="n">prop_stutter_invariant</span><span class="p">())</span></div>

<div class="viewcode-block" id="SpotAutomaton.is_complete"><a class="viewcode-back" href="../../../modules/logic.html#ggsolver.logic.SpotAutomaton.is_complete">[docs]</a>    <span class="k">def</span> <span class="nf">is_complete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Is the automaton complete? &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">spot</span><span class="o">.</span><span class="n">is_complete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spot_aut</span><span class="p">))</span></div>

<div class="viewcode-block" id="SpotAutomaton.is_semi_deterministic"><a class="viewcode-back" href="../../../modules/logic.html#ggsolver.logic.SpotAutomaton.is_semi_deterministic">[docs]</a>    <span class="nd">@models</span><span class="o">.</span><span class="n">register_property</span><span class="p">(</span><span class="n">Automaton</span><span class="o">.</span><span class="n">GRAPH_PROPERTY</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">is_semi_deterministic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Is the automaton semi-deterministic?</span>
<span class="sd">        See https://spot.lrde.epita.fr/doxygen/namespacespot.html#a56b3f00b7b93deafb097cad595998783</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">spot</span><span class="o">.</span><span class="n">is_semi_deterministic</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spot_aut</span><span class="p">))</span></div>

<div class="viewcode-block" id="SpotAutomaton.acc_name"><a class="viewcode-back" href="../../../modules/logic.html#ggsolver.logic.SpotAutomaton.acc_name">[docs]</a>    <span class="nd">@models</span><span class="o">.</span><span class="n">register_property</span><span class="p">(</span><span class="n">Automaton</span><span class="o">.</span><span class="n">GRAPH_PROPERTY</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">acc_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Name of acceptance condition as per spot&#39;s nomenclature. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spot_aut</span><span class="o">.</span><span class="n">acc</span><span class="p">()</span><span class="o">.</span><span class="n">name</span><span class="p">()</span></div>

<div class="viewcode-block" id="SpotAutomaton.spot_acc_cond"><a class="viewcode-back" href="../../../modules/logic.html#ggsolver.logic.SpotAutomaton.spot_acc_cond">[docs]</a>    <span class="nd">@models</span><span class="o">.</span><span class="n">register_property</span><span class="p">(</span><span class="n">Automaton</span><span class="o">.</span><span class="n">GRAPH_PROPERTY</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">spot_acc_cond</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Acceptance condition in spot&#39;s nomenclature.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spot_aut</span><span class="o">.</span><span class="n">get_acceptance</span><span class="p">())</span></div>

<div class="viewcode-block" id="SpotAutomaton.formula"><a class="viewcode-back" href="../../../modules/logic.html#ggsolver.logic.SpotAutomaton.formula">[docs]</a>    <span class="nd">@models</span><span class="o">.</span><span class="n">register_property</span><span class="p">(</span><span class="n">Automaton</span><span class="o">.</span><span class="n">GRAPH_PROPERTY</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">formula</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; The LTL Formula. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_formula</span></div>

<div class="viewcode-block" id="SpotAutomaton.is_state_based_acc"><a class="viewcode-back" href="../../../modules/logic.html#ggsolver.logic.SpotAutomaton.is_state_based_acc">[docs]</a>    <span class="nd">@models</span><span class="o">.</span><span class="n">register_property</span><span class="p">(</span><span class="n">Automaton</span><span class="o">.</span><span class="n">GRAPH_PROPERTY</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">is_state_based_acc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Is the acceptance condition state-based? &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spot_aut</span><span class="o">.</span><span class="n">prop_state_acc</span><span class="p">())</span></div>

<div class="viewcode-block" id="SpotAutomaton.is_weak"><a class="viewcode-back" href="../../../modules/logic.html#ggsolver.logic.SpotAutomaton.is_weak">[docs]</a>    <span class="nd">@models</span><span class="o">.</span><span class="n">register_property</span><span class="p">(</span><span class="n">Automaton</span><span class="o">.</span><span class="n">GRAPH_PROPERTY</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">is_weak</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Are transitions of an SCC all belong to the same acceptance sets?</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spot_aut</span><span class="o">.</span><span class="n">prop_weak</span><span class="p">())</span></div>

<div class="viewcode-block" id="SpotAutomaton.is_inherently_weak"><a class="viewcode-back" href="../../../modules/logic.html#ggsolver.logic.SpotAutomaton.is_inherently_weak">[docs]</a>    <span class="nd">@models</span><span class="o">.</span><span class="n">register_property</span><span class="p">(</span><span class="n">Automaton</span><span class="o">.</span><span class="n">GRAPH_PROPERTY</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">is_inherently_weak</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Is it the case that accepting and rejecting cycles cannot be mixed in the same SCC? &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spot_aut</span><span class="o">.</span><span class="n">prop_inherently_weak</span><span class="p">())</span></div></div>


<span class="k">def</span> <span class="nf">sat2formula</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">sat_assignments</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a subset of elements from powerset(atoms), generates a propositional logic formula</span>
<span class="sd">    that accepts exactly those elements.</span>

<span class="sd">    :param atoms: (Iterable[str]) The set of atoms.</span>
<span class="sd">    :param sat_assignments: (Iterable[powerset(atoms)]) A subset of powerset(atoms) representing</span>
<span class="sd">                            satisfiable assignments of the formula to be generated.</span>
<span class="sd">    :return: (str) String representing PL formula that accepts exactly the satisfying assignments.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Generate all clauses</span>
    <span class="n">formula</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">assignment</span> <span class="ow">in</span> <span class="n">sat_assignments</span><span class="p">:</span>
        <span class="c1"># Each clause includes an ANDing of atoms in assignment and ANDing of negation of atoms not in assignment</span>
        <span class="n">complete_acc</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">if</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">assignment</span> <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;!</span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">]</span>
        <span class="n">formula</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="s1">&#39; &amp; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">complete_acc</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

    <span class="c1"># Construct DNF formula by joining all clauses using disjunction</span>
    <span class="n">formula</span> <span class="o">=</span> <span class="s2">&quot; | &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">formula</span><span class="p">)</span>
    <span class="n">formula</span> <span class="o">=</span> <span class="n">PL</span><span class="p">(</span><span class="n">f_str</span><span class="o">=</span><span class="n">formula</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="n">atoms</span><span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>

    <span class="c1"># Simplify the formula</span>
    <span class="k">return</span> <span class="n">PL</span><span class="p">(</span><span class="n">f_str</span><span class="o">=</span><span class="n">formula</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="n">atoms</span><span class="p">)</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
    
    
        <div class="sidebar-toggle-group no-js">
            
            <button class="sidebar-toggle" id="sidebar-hide" title="Hide the sidebar menu">
                 
                <span class="show-for-small">hide menu</span>
                
            </button>
            <button class="sidebar-toggle" id="sidebar-show" title="Show the sidebar menu">
                
                <span class="show-for-small">menu</span>
                <span class="hide-for-small">sidebar</span>
                 
            </button>
        </div>
    
      <div class="clearer"></div>
    </div>
    <div class="relbar-bottom">
        
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
    <li><a href="../../../index.html">ggsolver 0.1.6 documentation</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">ggsolver.logic.base</a></li> 
      </ul>
    </div>
    </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2022, Abhishek N. Kulkarni.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.1.1.
    </div>
    <!-- cloud_sptheme 1.4 -->
  </body>
</html>